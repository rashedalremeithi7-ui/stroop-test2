<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Stroop Test — English</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; display:flex; flex-direction:column; align-items:center; padding:24px; }
    #stage { margin-top:40px; font-size:48px; height:120px; display:flex; align-items:center; justify-content:center; }
    .controls { margin-top:20px; display:flex; gap:8px; flex-wrap:wrap; }
    button.color-btn { padding:14px 22px; font-size:18px; border-radius:6px; border:1px solid #ccc; cursor:pointer;}
    #status { margin-top:20px; }
    #start { margin-top:16px; padding:8px 14px; }
    #export { margin-left:8px; }
    .small { font-size:14px; color:#444; margin-top:10px; }
  </style>
</head>
<body>
  <h1>Stroop Effect — English</h1>
  <div id="instructions">
    Press the button matching the ink color as fast as possible. There will be congruent (word matches color) and incongruent trials.
  </div>

  <div id="stage" aria-live="polite">Ready</div>

  <div class="controls" id="buttons"></div>

  <div>
    <button id="start">Start</button>
    <button id="export">Export CSV</button>
  </div>

  <div id="status"></div>
  <div class="small">Tip: use number keys 1–4 to respond (shown on each button).</div>

<script>
(() => {
  // Configuration
  const colors = [
    { name: 'RED',   hex:'#e53935', key:'1' },
    { name: 'GREEN', hex:'#43a047', key:'2' },
    { name: 'BLUE',  hex:'#1e88e5', key:'3' },
    { name: 'YELLOW',hex:'#f4b400', key:'4' },
  ];
  const TRIALS = 40;           // total trials (adjust)
  const PRACTICE = 6;          // practice trials shown before real run
  const interStimMs = 500;     // blank between trials

  // DOM
  const stage = document.getElementById('stage');
  const btns = document.getElementById('buttons');
  const startBtn = document.getElementById('start');
  const exportBtn = document.getElementById('export');
  const status = document.getElementById('status');

  // Build buttons
  colors.forEach((c, i) => {
    const b = document.createElement('button');
    b.className = 'color-btn';
    b.style.background = '#fff';
    b.style.borderColor = '#ccc';
    b.textContent = `${c.key} — ${c.name}`;
    b.dataset.color = c.name;
    b.addEventListener('click', () => handleResponse(c.name));
    btns.appendChild(b);
  });

  // State
  let trials = [];
  let currentIndex = -1;
  let trialStart = 0;
  let running = false;
  let practiceMode = false;

  // Helpers
  function randomInt(n){ return Math.floor(Math.random()*n); }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=randomInt(i+1); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
  function mkTrial(word, ink, isPractice=false){ return { word, ink, isCongruent: word===ink, isPractice, rt:null, correct:null, timestamp:null }; }

  // Create trial list (balanced)
  function buildTrials(total, practice=false){
    const list = [];
    for(let i=0;i<total;i++){
      const word = colors[randomInt(colors.length)].name;
      // Make congruent ~50% by flipping coin
      const congruent = Math.random() < 0.5;
      let ink = congruent ? word : colors.filter(c=>c.name!==word)[randomInt(colors.length-1)].name;
      list.push(mkTrial(word, ink, practice));
    }
    shuffle(list);
    return list;
  }

  // Prepare full run: practice then main
  function prepareRun(){
    trials = buildTrials(PRACTICE, true).concat(buildTrials(TRIALS, false));
    currentIndex = -1;
    running = true;
    practiceMode = true;
    status.textContent = `Practice: ${PRACTICE} trials. Get ready...`;
    nextTrial();
  }

  // Show next trial
  function nextTrial(){
    currentIndex++;
    if(currentIndex >= trials.length){
      running = false;
      showResults();
      return;
    }
    const t = trials[currentIndex];
    if(t.isPractice && !practiceMode){
      // skip practice if user hasn't started practice
    }
    // inter-stimulus blank
    stage.textContent = '';
    stage.style.color = '#000';
    setTimeout(()=> {
      // display stimulus
      displayStimulus(t);
    }, interStimMs);
  }

  function displayStimulus(trial){
    // Show the WORD as trial.word but colored with the trial.ink color
    const inkColor = colors.find(c=>c.name===trial.ink).hex;
    stage.textContent = trial.word;
    stage.style.color = inkColor;
    trialStart = performance.now();
    trial.timestamp = Date.now();
    // set a small timeout if you want to mark omissions; omitted here
  }

  function handleResponse(selectedColorName){
    if(!running || currentIndex < 0 || currentIndex >= trials.length) return;
    const rt = performance.now() - trialStart;
    const t = trials[currentIndex];
    if(t.rt !== null) return; // already responded
    t.rt = rt;
    t.correct = (selectedColorName === t.ink);
    // Provide brief feedback during practice
    if(t.isPractice){
      stage.textContent = t.correct ? '✓' : '✕';
      stage.style.color = t.correct ? '#2e7d32' : '#c62828';
      // keep practice mode visible until practice done
      if(currentIndex === PRACTICE - 1){
        practiceMode = false;
        status.textContent = 'Practice done — real trials starting.';
      }
      setTimeout(nextTrial, 600);
    } else {
      // no feedback for real trials; go to next
      nextTrial();
    }
  }

  // Keyboard mapping
  window.addEventListener('keydown', (e) => {
    const key = e.key;
    const c = colors.find(col => col.key === key);
    if(c) handleResponse(c.name);
  });

  startBtn.addEventListener('click', () => {
    if(running){ return; }
    prepareRun();
  });

  // Results computation
  function computeSummary(){
    const real = trials.filter(t=>!t.isPractice && t.rt!=null);
    const byCond = { congruent: real.filter(r=>r.isCongruent), incongruent: real.filter(r=>!r.isCongruent) };
    function avg(arr){ if(arr.length===0) return null; return arr.reduce((s,x)=>s+x.rt,0)/arr.length; }
    function accuracy(arr){ if(arr.length===0) return null; return arr.filter(x=>x.correct).length/arr.length; }

    // Per-word averages (word printed, regardless of ink)
    const perWord = {};
    colors.forEach(c => perWord[c.name] = { rts:[], avgRT:null, count:0, correctCount:0 });
    real.forEach(r => {
      perWord[r.word].rts.push(r.rt);
      perWord[r.word].count++;
      if(r.correct) perWord[r.word].correctCount++;
    });
    Object.keys(perWord).forEach(w=> {
      const a = perWord[w].rts;
      perWord[w].avgRT = a.length ? a.reduce((s,x)=>s+x,0)/a.length : null;
      perWord[w].accuracy = perWord[w].count ? perWord[w].correctCount / perWord[w].count : null;
    });

    const summary = {
      totalTrials: real.length,
      congruentCount: byCond.congruent.length,
      incongruentCount: byCond.incongruent.length,
      avgRT_congruent: avg(byCond.congruent),
      avgRT_incongruent: avg(byCond.incongruent),
      accuracy_congruent: accuracy(byCond.congruent),
      accuracy_incongruent: accuracy(byCond.incongruent),
      overallAvgRT: avg(real),
      overallAccuracy: accuracy(real),
      perWord
    };
    return { summary, trials: real };
  }

  function showResults(){
    const { summary } = computeSummary();
    status.innerHTML = `
      Trials finished.<br/>
      Total: ${summary.totalTrials}. Overall accuracy: ${(summary.overallAccuracy*100||0).toFixed(1)}%. Overall avg RT: ${(summary.overallAvgRT||0).toFixed(0)} ms.<br/>
      Congruent avg RT: ${(summary.avgRT_congruent||0).toFixed(0)} ms (acc ${(summary.accuracy_congruent*100||0).toFixed(1)}%).<br/>
      Incongruent avg RT: ${(summary.avgRT_incongruent||0).toFixed(0)} ms (acc ${(summary.accuracy_incongruent*100||0).toFixed(1)}%).`;
    // optionally show per-word
    let perWordText = '<br/>Per-word averages:<ul>';
    Object.entries(summary.perWord).forEach(([word,stats]) => {
      perWordText += `<li>${word}: avg RT ${(stats.avgRT||0).toFixed(0)} ms — acc ${(stats.accuracy*100||0).toFixed(1)}% (${stats.count} trials)</li>`;
    });
    perWordText += '</ul>';
    status.innerHTML += perWordText;
  }

  // Export CSV
  function exportCSV(){
    const { summary, trials: data } = computeSummary();
    if(!data || data.length===0){ alert('No data to export'); return; }
    // Per-trial CSV
    const header = ['trialIndex','word','ink','isCongruent','rt_ms','correct','timestamp'];
    const rows = data.map((t, i) => [i+1, t.word, t.ink, t.isCongruent, Math.round(t.rt), t.correct, t.timestamp]);
    const csv = [header.join(',')].concat(rows.map(r => r.map(cell => `"${cell}"`).join(','))).join('\n');

    // Download CSV
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `stroop_trials_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    // Also copy summary as JSON for convenience
    const summaryBlob = new Blob([JSON.stringify(summary,null,2)], { type: 'application/json' });
    const sUrl = URL.createObjectURL(summaryBlob);
    const sa = document.createElement('a');
    sa.href = sUrl;
    sa.download = `stroop_summary_${Date.now()}.json`;
    sa.click();
    URL.revokeObjectURL(sUrl);
  }

  exportBtn.addEventListener('click', exportCSV);

})();
</script>
</body>
</html>